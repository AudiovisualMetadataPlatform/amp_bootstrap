from amp.fileutils import read_json_file, write_json_file
from time import time
import csv

# NOTE: this is replicating the current segment structure.  It's badly
# structured, so this really should be fixed at some point.

### WORK IN PROGRESS ####


schema = {
    "$schema": "http://json-schema.org/schema#",
    'title': 'AMP Segments',
    'description': "Content generated by Segmentation and related tools",
    "type": "object",
    "properties": {
        'metadata': {
            'type': 'object',
            'properties': {
                'tool': {
                    'description': "The tool that created this transcript",
                    'type': 'string'
                },
                'version': {
                    'description': "The version of the tool that created this transcript",
                    'type': 'string',
                },
                'created': {
                    'description': "Creation time of this transcript in unix epoch seconds",
                    'type': 'number'
                },
                'variant': {
                    'description': "Which variation of segments format this is",
                    'type': 'string',
                    'enum': ['generic', 'diarization', ]
                }
            },
            'required': ['tool', 'version', 'created', 'variant']
        },
        'media': {
            'type': 'object',
            'properties': {
                'filename': {
                    'description': 'Source material for this transcript',
                    'type': 'string',
                },
                'duration': {
                    'description': 'Duration of the media in seconds',
                    'type': 'number',
                }
            },
            'required': ['filename', 'duration']
        },
        "segments": {
            "type": "array",
            "items": {
                "type": "object",
                "properties": {
                    "label": {
                        "type": ["null", "string"],
                        "description": "segment label"
                    },
                    "start": {
                        "type": "number",
                        "description": "start of segment in seconds"
                    },
                    "end": {
                        "type": "number",
                        "description": "end of segment in seconds"
                    },
                    "speakerLabel": {
                        "type": ["null", "string"]
                    },
                    "gender": {
                        "type": "string"
                    }
                },
                "required": ["end", "label", "start"]
            }
        },
        "numSpeakers": {
            "type": "integer",
            "description": "for diarization segments, the number of speakers"
        }
    },
    "required": ["media", "segments"]
}


class Segments:
    def __init__(self, tool: str, version: str, created: float=None,
                 media_filename: str='', media_duration: float=0,
                 segments: list=None):
        "Initialize an empty segments object"
        self.data = {
            'metadata': {
                'tool': tool,
                'version': version,
                'created': time() if created is None else created
            },
            'media': {
                'filename': media_filename,
                'duration': media_duration
            },
            'segments': [] if not segments is None else segments,
            'numSpeakers': 0
        }            
        

    @classmethod
    def load(cls, filename):
        "Load segments from a file"
        # create an empty instance and then overwrite the data from JSON
        instance = cls('', '')                
        instance.data = read_json_file(filename, schema)        
        return instance


    def save(self, filename):
        "Save segments to a file"
        write_json_file(self.data, filename, schema)


    def add_segment(self,):
	    pass




    def add_entity(self, type, text, beginOffset, endOffset, 
                   start: float=None,
                   score_type=None, score_value: float=None):
        "Add an entity to the data"
        self.data['entties'].append({
            'type': type,
            'text': text,
            'beginOffset': beginOffset,
            'endOffset': endOffset,
            'start': 0.0 if start is None else start,
            'score': {
                'type': score_type,
                'value': score_value
            }
        })


class Segmentation:
	MINIMUM_SILENCE = 10.0
	def __init__(self, segments=[], media=None, numSpeakers=0):
		self.segments = segments
		self.numSpeakers = numSpeakers
		if media is None:
			self.media = SegmentationMedia()
		else:
			self.media = media
			
	def addDiarizationSegment(self, start=None, end=None, speakerLabel = None):
		self.segments.append(SegmentationSegment(None, None, start, end, speakerLabel))

	def addSegment(self, label, gender=None, start=None, end=None, speakerLabel = None):
		# Format the label for comparison purposes
		tmp_label = SegmentationSegment.formatLabel(label)

		# Get the last segment if we have at least one in the list
		last_segment = None
		if len(self.segments) >= 1:
			last_segment = self.segments[-1]

		if last_segment is not None:
			logging.debug(last_segment)

		# If the time of the segment is less than 10 seconds, we have another segment, and the current 
		# segment is noise or silence, don't add it but add the time to the previous segment
		if (float(end) - float(start)) < self.MINIMUM_SILENCE and last_segment is not None and tmp_label in ('noise', 'silence'):
			last_segment.end = end
		else:
			# Format the gender
			tmp_gender = SegmentationSegment.formatGender(gender)

			# If the last segment matches the type, merge the two
			if last_segment is not None and last_segment.label == tmp_label and last_segment.gender == tmp_gender:
				last_segment.end = end
			else:
				# Otherwise add the segment
				self.segments.append(SegmentationSegment(label, gender, start, end, speakerLabel))

		if end is not None and end > self.media.duration:
			self.media.duration = end
		return





class SegmentationSegment:
	label = ""
	start = 0
	end = 0
	gender = None
	speakerLabel = None
	def __init__(self, label, gender=None, start=None, end=None, speakerLabel = None):
		self.label = SegmentationSegment.formatLabel(label)
		if gender is not None:
			self.gender = SegmentationSegment.formatGender(gender)
		self.start = start
		self.end = end
		self.speakerLabel = speakerLabel

	@staticmethod
	def formatGender( value):
		if value is None:
			return None
		tmp_value = value.lower()
		if tmp_value in ("male", "female"):
			return tmp_value.lower()
		return ""

	@staticmethod
	def formatLabel(value):
		if value is None:
			return None
		tmp_value = value.lower()
		if tmp_value in ("male", "female", "speech"):
			return "speech"
		elif tmp_value == "music":
			return "music"
		elif tmp_value in ("noactivity", "noenergy"):
			return "silence"
		return tmp_value

